在第一章中，我们定义“作用域”为：一套管理引擎怎么通过标志符在当前作用域和作用域链中查找变量的规则。



作用域有两种主要的工作模式。一种是目前最常见的，被大多数的编程语言所使用，那就是 **词法作用域**( Lexical Scope)。接下来我们会深入了解它。另一种叫做**动态作用域**（Dynamic Scope），现在仍然有一些语言在使用它。



动态作用域在附录A中有介绍。我提到动态作用域只是为了和词法作用域做一个对比。



### Lex-time

正如我们在第一章中讨论过的那样，一个标准的语言编译器的第一项工作就是词法解析（又名，分词解析）。回忆一下，词法解析的过程会审查源代码中的字符，并且赋予标志意义来作为有状态的解析的结果。



这就是理解词法作用域的概念及其名称来源的基础。



准确地定义： 词法作用域就是在词法解析阶段定义的作用域。换句话说，词法作用域是你编写变量和作用域块的地方为基础的，因此词法作用域在词法解析时是不变的。



**注意：**我们接下来就会看到一些欺骗词法作用域的方法，从而能够在词法解析后还能修改它，但是这部分内容有点难懂。事实上，把词法作用域仅仅当做词法关系是最佳实践，因此，书写时什么样，最终也就是什么样的。



考虑以下代码：

```JavaScript
function foo(a) {

	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}

	bar(b * 3);
}

foo( 2 ); // 2 4 12
```

这段代码里有三个嵌套的作用域。我们可以将这些嵌套作用域看做是一个包含一个的泡泡。																																																					

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fisw3tsd82j30gk0af3zc.jpg)

**泡泡1**包括了全局作用域，只有一个标识符：``foo``。

**泡泡2**包括了`foo`的作用域，包含了三个标识符：`a`,`b`和`bar`。

**泡泡3**包括了`bar`的作用域，只有一个标识符：`c`。



作用域泡泡由作用域块写在哪里所决定的，并且他们是逐级包含的。在下一章中，我们将会讨论作用域的其他部分，但是现在，我们先假定每个方法都会创造一个新的作用域泡泡。



`bar`的泡泡被完全地包含在`foo`的泡泡中，这是因为我们把`bar`这个方法定义在`foo`里面了。



注意，这些嵌套的泡泡们是严格的嵌套关系。他们不像韦恩图那样，气泡是可以相互穿越的。换句话说，没有一个泡泡是可以同时部分存在于另外两个泡泡中的，就像没有一个方法是可以部分地存在于两个父方法中的。



#### Look-ups

这些作用域泡泡的结构和相对位置向引擎充分地提供了所有需要查找标识符的位置信息。



在上面的代码片段中，引擎运行`console.log(...)`表达式时要查找3个引用的变量`a`,`b`和`c`。查找从最里面的作用域泡泡开始，也就是`bar(...)`方法的作用域。没有在这个作用域泡泡中找到`a`，所以往上一级也就是`foo(...)`的作用域泡泡中继续找。找到了`a`，就用这个`a`了。`b`同理。不过`c`已经在`bar(...)`中找到了。



如果在`bar(...)`和`foo(..)`里面都有一个`c`，`console.log(..)`表达式只会找到并使用在`bar(..)`里面的那个，永远不会去获取在`foo(..)`里面的那个。



**作用域在第一次得到匹配的标识符时就会停止查找。**在多层的嵌套作用域中可以存在相同名称的标识符，这叫做“遮蔽效应”（里面的那个标识符会“遮蔽”外面的那个）。不管遮蔽效应的话，作用域总是从程序运行所在处的最里层作用域开始查找，并逐级向外层/上层进行查找，直到找到，并停止。



**注意：**全局变量会自动地变成全局对象（在浏览器中就是`window`）的属性。因此一个全局变量可以不直接使用它的词义名称来引用，而是可以作为全局对象的一个属性被引用。

```javascript
window.a
```

这种技巧可以让你直接获取到全局变量而不用担心他会被遮蔽掉。非全局的被遮蔽掉的变量就没这么幸运了。



无论一个方法是在哪里被调用、怎么被调用的，它的词法作用域**只有**在它被声明的地方才会定义。



词法作用域的查找过程只适用于一级标识符，比如`a`,`b`和`c`。如果代码中有`foo.bar.baz`这样子的引用，词法作用域的查找只适用于`foo`，一旦找到这个变量，对象的属性访问规则就会接管接下来查找`bar`和`baz`的任务。



### Cheating Lexical

如果词法作用域仅仅只是在方法声明时被定义，也就是说它完全是由书写时所决定的。那么，怎么可能能够在运行时“修改”（也可以说，欺骗）词法作用域呢？



JavaScript有这样的两套机制。它们俩都被很多社区认为是差的实践。不过，典型的反对论点中经常缺少非常重要的一点：**欺骗作用域会导致性能更差**。



在我解释性能问题之前，让我们先来看看这两种机制是怎么工作的。



#### `eval`

`eval(..)`是JavaScript中的方法。传入一个字符串，将这字符串中的内容当做它已经在此刻存在于程序中了。换句话说，你不仅可以书写代码，你还可以直接写出可运行的代码，并直接运行它，就好像它在书写时就已经可以运行了一样。



以这个角度来理解`eval(..)`就应该很清楚了。`eval(..)`是通过欺骗和伪装成书写时的代码，来让你能够修改词法作用域了。



在`eval(..)`之后的代码已经运行的情况下，引擎就不在知道和关心之前的代码是否是动态插入的了，并修改词法作用域。引擎将会像平常一样，执行它的词法作用域的查找。



考虑以下代码：

```JavaScript
function foo(str, a) {
	eval( str ); // cheating!
	console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1 3
```

`“var b = 3;”`这个字符串是被欺骗的，当`eval(..)`被调用的时候，代码就已经在那了。因为这句代码声明了一个新的变量`b`，它就修改了已经存在的`foo`的词法作用域。事实上，就像上面提到的一样，这句代码实际上在`foo(..)`里面创建了一个变量`b`，这个变量`b`还遮蔽了在外部（全局）作用域中声明的那个`b`。



当`console.log(..)`被调用时，它将会在`foo(..)`的作用域中找到`a`和`b`，将用于不会去找外面的那个`b`。因此在这段代码执行后，将会打印出“1 3”，而不是“1 2”。



**注意：**在这个例子中，出于简单的演示的目的，我们传进去的“代码”串是固定不变的。但是它能很容易地将符合程序逻辑的字符串动态拼接后传进去。`eval(..)`一般被用来运行动态创建的代码，因为动态运行一段静态的固定不变的代码并没有比直接写在那更好。



默认情况下，如果传入`eval(..)`运行的那段代码中包含了至少一个声明（不管是变量还是方法），那么这个行为就会修改已存在的`eval(..)`所在的词法作用域。技术上来说，`eval(..)`能够被“直接”调用，通过一些技巧（超出了我们的讨论范围）能让它在全局作用域的环境中运行，因此也就修改了它。但是b不管在何种情况下，`eval(..)`都能在运行时修改编写时的词法作用域。



**注意：**当`eval(..)`在严格模式中被使用时，会在它自己的词法作用域中操作。这就意味着，在`eval()`内的声明不会修改外部的作用域。

```JavaScript
function foo(str) {
   "use strict";
   eval( str );
   console.log( a ); // ReferenceError: a is not defined
}

foo( "var a = 2" );
```



JavaScript中还有一些其他的效果与`eval(..)`类似的方法。`setTimeout(..)`和`setInterval(..)`的第一个参数可以是一个字符串，这个字符串里的内容会被当做是动态生成的代码。这种做法已经过时了，不要这么用！



方法构造器`new Function(..)`也可以传入一个字符串作为它的最后一个参数，并将其解释为动态生成的代码（如果有第一个参数的话，那它就是这个新方法的命名参数）。这个方法构造器语法比`eval(..)`稍微安全点，但是你依然要避免这么用它。



一般在你的代码中使用动态生成的代码是非常罕见的，因为它带来的性能损失不值得我们使用它。



#### `with`

`with`是JavaScript中另一个较难理解的用来欺骗词法作用域的技巧（不过，现在已经过时了）。

（过时了。。。一下没有动力翻这小节了=。=）



### Performance

`eval(..)`和`with`通过在运行时修改或创建新的词法作用域来欺骗撰写时定义的词法作用域。



你可能会问，这有啥意义？如果他们提供更复杂的功能及代码灵活度，那这些技巧是不是很棒呢？是的呀。



JavaScript引擎在编译阶段做了很多性能优化的工作。很多优化是基于能够根据代码的词法进行静态分析，并预先确定所有变量和函数声明的地方的，因此在运行时不费吹灰之力就能找到标识符。



但是如果引擎遇到了`eval(..)`或`with`，就要假定引擎所处理的标识符的位置可能会无效，因为引擎在词法解析阶段根本不知道你会在`eval(..)`或`with`里面传什么玩意来欺骗作用域。



在悲观的情况下，如果代码里面有`eval`或者`with`的话，引擎所做的很多优化就变得毫无意义，因此也就谈不上什么优化了。



如果你在代码中大量使用`eval(..)`或`with`，那你的代码的运行毫无疑问就会慢下来。无论引擎有多么努力地去控制这种不好的副作用，始终都绕不开这样一个事实：**没有优化，代码会运行地更慢。**



### Review (TL;DR)

词法作用域是在撰写代码时函数声明的位置所决定的。编译时的词法阶段本质上是能够知道全部标识符是在哪里以及如何声明的，因此能够在运行阶段预测它们是怎样被找到的。



JavaScript中有两个机制可以“欺骗”词法作用域：`eval(..)`和`with`。前者通过运行一串拥有至少一个声明的“代码”，可以在代码运行时修改已经存在的词法作用域。后者本质上是通过将一个对象的引用当做“作用域”、把它的属性当做作用域的标识符，进而在代码运行时创建了一个全新的词法作用域。



这两个机制的不好的地方在于：它们会让引擎在编译时关于作用域查找方面的优化能力骤降。因为引擎只能悲观地假定这些优化都是无效的。用了它们，代码就会运行地更慢。所以答应我，**不要使用它们**！

