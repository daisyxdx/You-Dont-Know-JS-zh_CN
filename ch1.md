# chapter1:What is Scope?

对于几乎所有的编程语言来说，一个最基本的例子就是存储变量，并能在之后检索或修改它。事实上，能够存储变量并取出值的能力就是赋予一个程序state（状态）。



如果没有这么一个概念，那么一个程序虽然能实现很多任务，但是他们就会变得非常受限和无趣。



但是在我们的程序中产生变量就会引发一个有趣的问题：这些变量都“活”在哪？换句话说，他们都存在哪？另一个非常重要的问题：当我们的程序需要某个变量的时候，是怎么找到它的？



上述的问题就是在讲一套定义的非常好的存储变量并在之后找到他们的规则的必要性。我们称这套规则为：scope（作用域）。



但是，作用域规则是怎么来的呢？

## Compiler Theory

你或者会觉得这是一件不言而喻，或者会觉得是一件令人惊讶的事，这完全取决于你对各种语言的理解水平：尽管JavaScript是属于“动态的”或者是“可理解的”的语言的语言类别，但是它实际上是一种编译语言。JavaScript不像很多其他传统的编译型语言是提前编译好的，编译结果在各个分布式系统上也不可移植。



但是尽管如此，JavaScript引擎用比我们还要复杂的方式，在很多传统的语言编译器中执行许多相同的步骤。



在传统的语言编译器的工序中，一大坨的源码，也就是你的程序，在被执行前一般将会经历3个步骤。笼统地讲，这就是编译：

**1.Tokenizing/Lexing**：一串字符拆分出来的对语言来说有意义的代码块被称为token（标记）。举个例子，`var a = 2;`这个程序将会被拆分成这样子的标记：var,a,=,2和;。空白键会不会成为一个标记取决于它是不是有意义。



注意：标记解释和词法解析之间的区别是非常微妙和学术的，它们的区别主要取决于这些标记的定义是否有状态。简单来说，如果标记解析器用有状态的语法规则来决定a是一个标记还是某个标记的一部分，这个就叫做lexing（词法解析）。



**2.Parsing**：将一组标记转化成能代表程序的语法结构的元素嵌套树，那么这个树就叫做AST(**A**bstract **S**yntax **T**ree)(抽象语法树)。



举例：`var a = 2; `这句代码的树应该从一个叫做VariableDeclaration（变量声明）的顶级节点开始，它的一个子节点叫做Identifier（标识符）（其值为a）；另一个子节点叫做AssignmentExpression（赋值表达式）。AssignmentExpression的子节点叫做NumericLiteral（数字字面量）（它的值为2）。



**3.Code-Generation**：代码生成就是将AST（抽象语法树）转化成可执行代码的过程。这个过程在不同的语言和目标平台等因素影响下会有很大不同。



因此，我们不需要深入细节，我们只要知道有一种方法能够将我们的`var a = 2;`描述成AST并且将其转化成一套能真正的创建变量a（包括为其分配内存等等）并且能够将一个值存入a中的机器指令。



注意：引擎管理系统资源的细节比我们挖掘的还要深的多，所以，我们只要假定引擎能够创建存储变量就可以了。



正如其他语言编译器，JavaScript引擎要比上述的三个步骤复杂得多。比如说，在解析和代码生成的过程中有特定的步骤来优化执行，包括销毁冗余元素等等。



所以，我只是大致地介绍到这个地步。但是我认为，你马上就会知道引擎为啥要做这些细节，甚至是在一个很高的水平上来做。



就为了一件事，JavaScript引擎不能像其他语言一样拥有足够的时间来进行优化，因为JavaScript不能像其他语言一样，在构建时提前编译。



对JavaScript来说，很多时候在代码被执行前仅仅只有几毫秒（甚至更少）的时间来编译。为了能够有更快的性能，JS引擎使用了各种各样的技巧（比如懒编译热更新的JITs等）。不过这些已经在我们这本书要讨论的范畴之外了。



为了简单起见，我们只要明确，在JavaScript代码执行之前必须经过编译。因此，JS编译器将会把程序比如说`var a = 2;`先进行编译，然后马上准备运行它。

## Understanding Scope

下面我们用思考进程是怎么对话的方法来学习理解作用域。但是，谁拥有它呢？

### The Cast

让我们来看看这些与程序` var a = 2;`的进程进行互动的人物表，这样我们就能立刻理解这些会话。

1.引擎：负责我们的JavaScript程序开始编译到运行结束的所有过程。

2.编译器：引擎的一个朋友。处理所有的代码解析和生成的粗活（详见上一节）。

3.作用域：引擎的另一个朋友。收集并保有一个记录所有申明的标识符（变量）的列表，并且强制执行一套严格的规则，这套规则专门用来规定当前正在运行的代码怎么获取到这些变量。



为了你能完全理解JavaScript是怎么工作的，你需要像引擎和它的朋友们那样思考，像它们一样提出问题，也像它们一样回答这些问题。



### Back & Forth

当你看到`var a = 2;`时，你最有可能将其当做一个表达式。不过，我们的新朋友引擎可不是这么看待它的。事实上，引擎将其看成两个表达式，一个用来编译，一个用来运行。



那么，让我们来看看引擎和它的朋友们是怎么分解`var a = 2;`这个代码的吧。



编译器做的第一件事就是将程序解析成token（标记），然后将token（标记）转化成抽象语法树。不过，在编译器要进行代码生成时，将会把代码处理得稍微与原来预想的有些不同。



一个合理的假设就是：编译器会产生能够被下面这句伪代码所归纳的代码：“给一个变量分配内存，标记它为a，将值2放进这个变量”。不幸的是，这样的做法并不总是正确的。



编译器会把进程替代为：

1.当遇到` var a`时，编译器会询问作用域这个变量a是否已经在特定的作用域中存在。如果存在，编译器就会忽略这句声明，并继续编译下去；否则，编译器就会让作用域在变量所在的作用域中声明一个新的叫做a的变量。

2.然后编译器就生成能在引擎中运行和处理`a = 2`的代码。引擎运行这个代码时，会先询问作用域在当前的作用域中是否存在一个叫做a的变量。如果有，引擎就会用这个变量；如果没有，引擎就会在别的地方寻找（请看之后的作用域链章节）。



如果引擎最终找到了一个变量，那么就把值2赋给它。如果没有，引擎就会举起它的手并大喊：这里有个错误！



总结：为了分配变量，做了两个的步骤：第一，编译器会声明一个变量（如果这个变量之前没有在当前作用域中声明过）；第二，引擎会在作用域中寻找这个变量并赋值，如果能找到的话。

### Compiler Speak

为了更深的理解，我们需要更多的编译器术语。



当引擎运行编译器在步骤2中产生的代码时，不得不查询变量a，看看它是不是已经被声明了。这种查询需要与作用域协作。但是，引擎执行的查询类型会影响查询的结果。



在我们这个例子中，引擎执行的是“LHS”查询。另一个查询类型是“RHS"。



我打赌你一定猜出了"L"和“R”的意思。他们代表着“Left-hand Side”（左侧）和"Right-hand Side".（右侧）。



那么是什么东西的左侧和右侧呢？当然是一个赋值操作的左侧和右侧啦。



换句话说，当一个变量出现在赋值操作的左侧时，那么就执行LHS查询。当一个变量出现在赋值操作的右侧时，执行RHS查询。



讲真，更精确地说，RHS查询就是简单地查找某个变量的值。而LHS查询查找的是变量这个容器本身，所以它才能进行赋值。在这层理解上，RHS其实也就不是真正意义上的“一个赋值的右侧”了，更精确地讲，它只是表示“不是左侧”而已。



如果只是不严谨地讲的话，你也可以认为，RHS仅仅只是表示“这个值要给谁”。



接下来，让我们继续深入理解。



考虑以下代码：

```
console.log( a );
```

对a的引用是一个RHS引用，因为这里对a没有赋值。但是，我们又要检索a的值，才能将值传给`console.log(..)`。



对比以下代码：

```
a = 2;
```

这里a的引用是一个LHS引用，因为我们并不关心现在的值等于多少，我们只是想要找到= 2这个赋值操作的目标对象。



**注意：**LHS和RHS表示为“一个赋值的左侧/右侧”，但并不是字面上理解的“赋值操作符=的左侧/右侧”。赋值还有很多其他的方式，所以最好从概念上这么理解它们：LHS:赋值的目标对象是谁，RHS:获取某个变量的值。



考虑以下代码，这段代码同时用了LHS和RHS引用：

```javascript
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```



拆分为一下三句代码来讲：

```
foo( 2 );
```

最后一行代码中对`foo(..)`方法的调用用到了RHS引用，表示：”去找到foo的值，并把它给我“。另外，`(..)`表示`foo`的值必须要执行，所以，它最好是个方法。

另外，这里还有一个不容易发现但是很重要的赋值，你发现了么？在这段代码中，你可能忽略了一句隐晦的代码：`a = 2`。这句代码发生在值2作为一个参数传入方法`foo(..)`中，此时，值2被分配给了变量a。虽然很隐晦，但这就是一个LHS查询。



```
console.log( a ); 
```

对于a，还有一个RHS引用，得到值用来传给`console.log(..)`。`console.log(..)`本身也需要一个引用才能运行。所以对于`console`这个对象来说也有一个RHS查询：对console进行属性解析看看是否存在一个叫做`log`的方法。



```
log( a );
```

在把值2传递给`log(…)`时，LHS和RHS都发生了。RHS:通过a的RHS查询，传入了值2。LHS：在`log(…)`的内部实现中，我们认为一定传入了参数，在将2赋值给第一参数之前，它一定先做了一次LHS引用查询。



**注意：**你可能会把`function foo(a) {…`这样子的方法声明当做是一个普通的变量声明和赋值，可将其拆分为var foo和`foo = function(a){…`。用这种方法来理解的话，就会让人觉得方法声明是个LHS查询。

然而，一个微妙而重要的区别就是，编译器在第三步——代码生成的过程中，对方法声明同时处理了声明和值的定义。因此，当引擎运行代码的时候，是不需要再将方法“分配给”`foo`了。因此，是不应该将方法声明看做是一个LHS查询和赋值的。



**埖埖：**ydkjs只是说不同的查询方式会给结果带来不同，但是却具体说是啥子不同，这样子很不利于更好的利用啊。RHS是去找某个变量的值，因此这个变量是有可能不存在的，如果不存在时，就会报错或defined；LHS是将值赋给某个变量，当在作用域中找不到变量时，就创建一个全局的变量来存放这个值，因此在非严格模式下，怎么样都不会报错。

还有那个方法声明的，bibi说一堆，其实就是我们常说的，整个声明都被提升了嘛。



### Engine/Scope Conversation

```javascript
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

让我们来把上面这段代码的处理过程转变为一段对话吧。那么，这段对话将会像是这个样子：

> **Engine**: hey，作用域，我想对`foo`做一个RHS引用，你有见过它么？

> **Scope：**是啊，我有啊。编译器刚刚声明了它。它是个方法，我现在就给你。

> **Engine:**太好了，谢谢！我要运行`foo`了。

> **Engine**: hey，作用域，我现在想对``a``做一个LHS引用，你有见过它么？

> **Scope**: 有啊，编译器将它声明为一个传给``foo``的参数。把它给你。

> **Engine**:作用域，你对我帮助太大了，谢谢你。现在，我要把``2``赋给``a``了。 

> **Engine**:作用域啊，很抱歉又要打扰你了。我需要对``console``做一个RHS查询，你见过它么？

> **Scope**:没问题，这个是我的工作。没错，我见过它，它是内置的。给你。

> **Engine**:完美！寻找``log(...)``中，好的，找到了，他是个方法。 

> **Engine**: 作用域，你能帮我看看``a``的RHS引用么。我是记得有这个变量的，不过我还是想再确认一遍。

> **Scope**: 引擎你是对的。它没有被改动过，拿去吧。

> **Engine**:真棒！现在我要把``a``的值``2``传给``log(..)``。 

> ...

#### 小测验

看一看你现在理解得怎么样了。指出一下代码中引擎所做的事情，以及引擎和作用域之间的对话。

```javascript
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1、指出所有的LHS查询（一共有3处）。

2、指出所有的RHS查询（一共有4处）。

**Note：**答案在本章的小结中。

### Nested Scope

我们之前说过，作用域是一套用来通过标识名来寻找变量的规则。然而，一般情况下作用域不止一个。



当一个方法代码块嵌套在另一个方法代码块中时，作用域也就产生了嵌套。因此，如果一个连梁不能再当前的作用域中找到的话，引擎就会向上一层的作用域询问。如果还找不到，引擎就会一层一层地向上询问，直到问到最外层的作用域（又名，全局作用域）。



考虑以下代码：

```javascript
function foo(a) {
	console.log( a + b );
}

var b = 2;

foo( 2 ); // 4
```

对``b``的RHS引用不能在``foo``方法中被解决，但是它能在``foo``所在的作用域中解决（在这里，就是全局作用域）。



因此，再来看下引擎和作用域之间的对话，我们将会看到：

> **Engine**: hey，在``foo``的作用域中是否有``b``？有的话，就它进行下RHS查询吧。

> **Scope**: 没有见过。

> **Engine**:  hey，``foo``外面的那个作用域，哦，你就是全局作用域啊，太棒了。你有见过``b``么？给他做一次RHS引用吧。

> **Scope**:当然见过了，给你。 



在作用域链中的一个简单的规则：引擎先从当前正在执行的作用域中寻找变量。如果没找到，就一直向上一个作用域去找。如果已经到了全局作用域了，不管有没有找到变量，都得停止寻找。



#### Building on Metaphors

为了更加直观的理解作用域链，可以把作用域链想象成下面这栋建筑。

![fig1](/Users/daisy/Library/Mobile Documents/com~apple~CloudDocs/demo/blog/YDKJS-Scope and Closures/fig1.png)

这栋建筑就代表了我们程序中的作用域链的那套规则。建筑中的一楼代表了代码的当前作用域。建筑的顶楼代表了全局作用域。

你首先在当前楼层解决LHS引用和RHS引用。如果你没找到，就坐电梯到上一层，在这层继续寻找。就这样一层一层地找。一道你到达顶楼（也就是全局作用域）时，不管有没有在这层楼里找到，你都只能停下来了。



### Errors

为啥我们要区分LHS和RHS呢？



因为当变量没有在作用域中声明的情况下，这两种类型的查询会有不同的效果。



考虑：

```javascript
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

当``b``的第一次RHS查询发生时，``b``是找不到的。也就是说，``b``是一个未声明的变量。



当RHS查询在作用域链中没有找到变量时，引擎就会扔出一个``ReferenceError``异常。请注意，这是一个``ReferenceError``类型的异常。



但是LHS就不同了。如果引擎需要执行LHS查询，并且已经到了全局作用域了还没找到需要找的变量，并且程序是在"非严格"的模式下运行的，那么**在全局作用域**中就会创建一个新的变量，并且变量名就是LHS需要查找的那个变量的名字，再将这个变量给引擎。



_"不，从来就没有一个这样子的变量，但是我热心地帮你创建了一个。"_



从ES5开始添加了"严格模式"，和正常/轻松/懒散模式相比，严格模式在行为上有很多不同。其中一个就是，严格模式下禁止在全局中自动地隐性地创建变量。所以在刚才那种情况下，全局作用域不会返回变量给LHS查询，引擎就会像RHS时一样抛出``ReferenceError``。



如果一个变量是通过RHS引用找到的，但是你对它的值做了不能做的操作，比如说想要像对一个非方法类型的值进行方法调用，或者调用``null``或``undefined``的属性，那么引擎就会扔出一个叫做``TypeError``的异常。



``ReferenceError``和作用域的解析失败相关。``TypeError``暗示了作用域解析是成功的，但是对结果做了非法/不允许的操作。



#### Review (TL;DR)

作用域是一套决定变量是在哪里及怎样被查找的。一种查找是为了给变量赋值的LHS查找；另一种查找是为了找到变量的RHS查找。



LHS引用来自赋值操作。作用域相关的赋值即在``=``操作符中发生，又在方法传参时发生。



JavaScript引擎先编译后运行。在这个过程中，它将声明切分成两个单独的步骤，如``var a = 2;``：

1.首先 是`var a` ，将其声明在作用域中。这个一开始就发生了，遭遇代码运行。

2.然后， `a = 2` ，寻找这个变量（LHS查询）并给它赋值。



LHS和RHS首先在当前正在运行的作用域中查找，如果必要的话（当在这个作用域中找不到时），他们就会在作用域链中去查找，一次一个作用域，直到达到最顶层的全局作用域才停止，不管有没有找到那个变量。



失败的RHS引用就会导致 `ReferenceError`异常。失败的LHS引用会导致一个自动地隐性地创建一个以那个变量名命名的全局的变量。（如果是“严格模式”，也会产生 `ReferenceError`）



### Quiz Answers

```javascript
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1. Identify all the LHS look-ups (there are 3!).

   **c = .., a = 2 (implicit param assignment) and b = ..**

2. Identify all the RHS look-ups (there are 4!).

   **foo(2.., = a;, a + .. and .. + b**















