在第2章，我们将“动态作用域”作为“词法作用域”的对比时，谈及了它。



为了让大家能够了解到它们之间差异，让我们来简单地研究下动态作用域。动态作用域更像是JavaScript里面的另一个机制（`this`）。这个机制我们将会在“*this & Object Prototypes*”这本书中仔细研究。



正如第2章所说，词法作用域是关于引擎是怎么查找变量以及怎么找到变量的一套规则。词法作用域的关键特征是：它是在代码书写时就被定义下来的（假设你不用`eval`和`with`来欺骗作用域）。



动态作用域是指作用域的是在运行时动态变化的，而不是在书写阶段静态确定的。考虑以下代码：

```JavaScript
function foo() {
	console.log( a ); // 2
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```

词法作用域对在`foo()`里的`a`有一个RHS引用，这个引用找到了全局的`a`变量，导致了代码运行后，打印出来的是`2`。



而动态作用域则不关心函数和作用域在哪里以及怎么声明的，只关心他们是在哪里被调用的。换句话说，作用域链式基于调用栈的，而不是作用域嵌套。



因此，如果JavaScript是使用动态作用域的，当`foo()`运行时，理论上来说，代码的运行结果就是输出`3`。

```JavaScript
function foo() {
	console.log( a ); // 3  (not 2!)
}

function bar() {
	var a = 3;
	foo();
}

var a = 2;

bar();
```

为什么会这样呢？当`foo()`内无法找到`a`时，它不再逐步向上在嵌套（词法）作用域中查找，而是使用调用栈去找`foo()`是在哪里调用的。由于`foo()`是在`bar()`中被调用的，它就会在`bar()`的作用域中查找变量，这样子就找到了一个值等于`3`的变量`a`。



你可能一开始会觉得很奇怪。



可能只是因为你只接触过使用词法作用域的语言吧。因此会觉得动态作用域很陌生。如果你曾经书写过使用动态作用域的语言，那么你就会觉得动态作用域很自然，而词法作用就会变量很奇怪了。



再一次明确一件事：**JavaScript没有动态作用域。**它是使用词法作用域的。但是`this`机制有点像动态作用域。



关键区别：**词法作用域是在书写阶段确定的，动态作用域（还有`this`）是在运行时确定的。**词法走用于关心函数是在哪里声明的，动态作用域关心函数是在哪里被调用的。



最后：`this`关心方法是怎么被调用的。这表明，`this`机制和动态作用域是很相似的了。想要更多了解`this`，请阅读“*this & Object Prototypes*”。





